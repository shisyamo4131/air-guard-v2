# エラーハンドリング機能の改善

## 概要

Step 5 では、統一されたエラーハンドリングシステムを導入し、各コンポーザブルにロバストなエラー処理機能を追加しました。

## 新規作成したファイル

### `useErrorHandler.js`

統一されたエラーハンドリング機能を提供するコンポーザブル。

**主な機能:**

- エラーの自動分類（ネットワーク、権限、バリデーション等）
- エラー重要度の判定
- ユーザーフレンドリーなメッセージ生成
- 自動リトライ戦略の提供
- 安全な非同期実行

## 改善されたファイル

### `useWorkerManager.js`

作業員管理の全機能にエラーハンドリングを追加:

**改善点:**

- すべての作業員取得・検索機能に例外処理を追加
- データ検証とサニタイゼーション
- 一括取得時の自動リトライ機能
- エラー発生時のフォールバック処理

### `useScheduleState.js`

スケジュール状態管理の全機能にエラーハンドリングを追加:

**改善点:**

- 楽観的更新時の例外処理
- マトリックス作成時のデータ検証
- フィルタリング条件の検証
- セル更新時の整合性チェック

## エラーハンドリングの利用例

```javascript
// useWorkerManagerでのエラーハンドリング
const workerManager = useWorkerManager();

// 安全な作業員データ取得
const result = await workerManager.fetchWorkers([
  { workerId: "emp001", isEmployee: true },
  { workerId: "out001", isEmployee: false },
]);

if (!result.success) {
  console.log("取得失敗:", result.error.userMessage);
  // リトライが可能な場合は自動リトライ済み
}

// 検索機能（エラー時は空配列を返す）
const searchResults = workerManager.searchWorkers("田中");
// 内部でエラーが発生しても例外は投げられない

// useScheduleStateでのエラーハンドリング
const scheduleState = useScheduleState({ schedules });

// 安全なスケジュール更新
const updated = scheduleState.optimisticUpdate("schedule123", (schedule) => {
  return { ...schedule, status: "completed" };
});

if (!updated) {
  console.log("更新に失敗しました");
  // エラーは内部でログ記録済み
}
```

## エラーの分類

1. **NETWORK**: ネットワーク関連エラー（自動リトライ対象）
2. **VALIDATION**: 入力データの検証エラー
3. **PERMISSION**: 権限不足エラー
4. **NOT_FOUND**: データ未発見エラー
5. **TIMEOUT**: タイムアウトエラー（自動リトライ対象）
6. **UNKNOWN**: その他のエラー

## エラー重要度

1. **LOW**: ログのみ、ユーザー通知なし
2. **MEDIUM**: 警告レベル、ユーザー通知
3. **HIGH**: エラーレベル、ユーザー通知
4. **CRITICAL**: クリティカル、即座にユーザー通知

## リカバリー戦略

エラーの種類に応じて適切なリカバリー戦略が自動で適用されます:

- **ネットワークエラー**: 2 秒後に自動リトライ（最大 3 回）
- **タイムアウト**: 5 秒後に自動リトライ（最大 2 回）
- **バリデーションエラー**: リトライなし、入力修正を促す
- **権限エラー**: リトライなし、管理者連絡を促す

## 利点

1. **統一性**: 全コンポーザブルで一貫したエラー処理
2. **ロバスト性**: 予期しないエラーでもアプリケーションが停止しない
3. **ユーザビリティ**: わかりやすいエラーメッセージとガイダンス
4. **保守性**: エラーハンドリングのロジックが集約されている
5. **デバッグ性**: 詳細なログとエラー分類で問題特定が容易

## 次のステップ

エラーハンドリングの改善により、アプリケーションの安定性と保守性が大幅に向上しました。次のステップでは、パフォーマンスの最適化を行います。
